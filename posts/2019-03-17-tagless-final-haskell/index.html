<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Tagless Final Encoding in Haskell
    </title><link href=/favicons/favicon.ico rel=icon type=image/png><link href="https://jproyo.github.io/ atom.xml" title="Tech, Science, Math and more..." rel=alternate type=application/atom+xml><link href=https://jproyo.github.io/main.css media=screen rel=stylesheet><script src=https://jproyo.github.io/elasticlunr.min.js></script><script src=https://jproyo.github.io/search_index.en.js></script><script src=https://jproyo.github.io/search.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe onload=renderMathInElement(document.body); src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><meta name=description><meta name=description><meta content="index, nofollow" name=robots><meta content="Tech, Science, Math and more..." property=og:title><meta content=article property=og:type><meta content=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/ property=og:url><meta property=og:description><meta content="Tech, Science, Math and more..." property=og:site_name><body><header><div class=navbar><div class="nav-title nav-navs"><a class="nav-links home-title" href=https://jproyo.github.io>Tech, Science, Math and more...</a></div><nav class="nav-title nav-navs"><a class=nav-links href=/posts> Articles</a><a class=nav-links href=/tags> Tags</a></nav><nav class="socials nav-navs"><div class=search-container><input placeholder="üîé   Search" id=search type=search><div class=search-results><div class=search-results__items></div></div></div><label class=theme-switcher for=themeswitch><div class=background></div> <input id=themeswitch type=checkbox> <div class=switch><img alt="theme switch to dark" class=moon src=/menu_icon/moon.png><img alt="theme switch to light" class=sun src=/menu_icon/sun.png></div></label></nav></div></header><div class=content><main><article><div class=title><h2>Tagless Final Encoding in Haskell</h2><div class=meta>Posted on <time>2019-03-17</time><div class=post-tags><nav class="nav tags">üè∑: <a href=https://jproyo.github.io/tags/haskell/>haskell</a> ¬† <a href=https://jproyo.github.io/tags/fp/>fp</a> ¬† <a href=https://jproyo.github.io/tags/functional/>functional</a> ¬† <a href=https://jproyo.github.io/tags/tagless/>tagless</a> ¬† <a href=https://jproyo.github.io/tags/final/>final</a> ¬† <a href=https://jproyo.github.io/tags/encoding/>encoding</a> ¬† <a href=https://jproyo.github.io/tags/type/>type</a> ¬† <a href=https://jproyo.github.io/tags/level/>level</a> ¬† <a href=https://jproyo.github.io/tags/programming/>programming</a> ¬†</nav></div> ||<span> 9 minute read</span></div></div><h1>Table of Contents</h1><ul><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#source-code>Source Code</a><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#introduction>Introduction</a><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#why-tagless-final>Why Tagless Final?</a><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#what-is-tagless-final-encoding>What is Tagless Final Encoding?</a><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#tagless-final-encoding-in-practice>Tagless Final Encoding in practice</a><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#provide-and-test-with-different-implementations-using-type-application>Provide and Test with different implementations using Type Application</a> <ul><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#instances>Instances</a></ul><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#extensibility>Extensibility</a> <ul><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#horizontal-extensibility>Horizontal Extensibility</a></ul><li><a href=https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell/#conclusion>Conclusion</a></ul><section class=body><h2 id=source-code>Source Code</h2><p>You can find source code of the example described in this post <a href=https://gist.github.com/jproyo/7127418371a6d6254ff2208bf26c0315>here</a><h2 id=introduction>Introduction</h2><p>In this post i am going to explore a simple technique for organizing our programs which is called <strong>Tagless Final Encoding</strong> to write testable programs in Haskell. I am also use <strong>TypeApplication LANGUAGE</strong> directive to write more readable and flexible test.<h2 id=why-tagless-final>Why Tagless Final?</h2><p>Nowadays in Haskell Community there is an open discussion about using <a href=http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html>Free Monads</a>, <a href=http://hackage.haskell.org/package/mtl>mtl</a> or <strong>Tagless Final Encoding</strong> to write internal <strong>DSL</strong> (Domain Specific Language) for representing our programs in a descriptive and Functional way.<p>In my personal opinion i think all of these tools, theories and techniques are suitable to do it but depends on the context of the person, team or solution you are writing to decide which is more useful.<p>For example:<ul><li><p><strong>Free Monad</strong>: I think it is great to have tools that are based on <em><strong>Category Theory</strong></em> concepts such as <strong>Free Applicative</strong>, <strong>Free Monad</strong> and so on. There is a great paper about this <cite><a href=https://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf>Notions of Computation as Monoid</a></cite>. In that sense <strong>Free Monad</strong> not only help us to describe our programs but also to have certain Math Properties in our toolbox to manipulate them. Although i have never benchmarked any of the <strong>Free Monad</strong> implementations out there, i know there are complains about their performance in the community. Beyond this i think for beginners it is a little difficult to implement.</p><li><p><strong>Monad Transformers (mtl)</strong>: Also great tool, based on simple <strong>Monad</strong> concept which is easier to understand for beginners and without performance penalties if you are using carefully. It is also the most used tool for dealing with different <strong>Monads</strong> in a single program from the beginning of Haskell. The only disadvantage i could pointed out is that is less readable and understandable in the code when you are stacking more than 3 Monads. Also a drawback for beginners.</p><li><p><strong>Tagless Final</strong>: You only need to define and implement <strong>Typeclasses</strong>. In the original post i have wrongly mentioned <em>"it is a technique not based on any paper or Math Theory"</em>, but thank you to <a href=https://www.reddit.com/user/p-alik>p-alik</a> who pointed me out in reddit channel that there is paper for this here <cite><a href=http://okmij.org/ftp/tagless-final/index.html#course-oxford>Typed final (tagless-final) style</a></cite>. The main advantage for me is it is beginner friendly, readable, easy to understand, test and extend.</p></ul><p>Having said that, I would like to talk about <strong>Tagless Final</strong> as an approach for Haskell beginners in order to help them to organize and describe programs; make them extensible and testable.<h2 id=what-is-tagless-final-encoding>What is Tagless Final Encoding?</h2><p><strong>Tagless Final Encoding</strong> is a technique for embedding a <strong>DSL</strong> (Domain Specific Language) in a <strong>Functional Programming Language</strong>. We need to define a <em><strong>Language</strong></em> for using it and an <strong>Interpreter</strong> to indicate how it should behave on each defined term. For this purpose we are going to use <strong>Typeclasses</strong>.<p>To sum up in <strong>Tagless Final Encoding</strong> style there are:<ul><li><p><strong>Typeclasses</strong>: Set of operations over a Type.</p><li><p><strong>Interpreter</strong>: Instances of those Typeclasses for each specific Type</p></ul><h2 id=tagless-final-encoding-in-practice>Tagless Final Encoding in practice</h2><p>We are going to build a basic program which request some user data. The program is going to do the following:<ul><li>First try to recover the data from a cache<li>If data is found it is returned<li>If there is no data in the cache, search user data in source repository and update cache</ul><pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-keyword z-other z-haskell">type</span> <span class="z-constant z-other z-haskell">UserName</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">String</span>

<span class="z-keyword z-other z-haskell">data</span> <span class="z-constant z-other z-haskell">DataResult</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">DataResult</span> <span class="z-constant z-other z-haskell">String</span>
  <span class="z-meta z-deriving z-haskell"><span class="z-keyword z-other z-haskell">deriving</span> (<span class="z-entity z-other z-inherited-class z-haskell">Eq</span>, <span class="z-entity z-other z-inherited-class z-haskell">Show</span>)</span>

<span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">requestData</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">Monad</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-keyword z-other z-big-arrow z-haskell">=></span> <span class="z-storage z-type z-haskell">UserName</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> [<span class="z-storage z-type z-haskell">DataResult</span>]
</span>requestData userName <span class="z-keyword z-operator z-haskell">=</span> <span class="z-keyword z-control z-haskell">do</span>
 cache  <span class="z-keyword z-operator z-haskell">&LT-</span> getFromCache userName
 result <span class="z-keyword z-operator z-haskell">&LT-</span> <span class="z-keyword z-other z-haskell">case</span> cache <span class="z-keyword z-other z-haskell">of</span>
   <span class="z-constant z-other z-haskell">Just</span> dataResult <span class="z-keyword z-operator z-haskell">-></span> return dataResult
   <span class="z-constant z-other z-haskell">Nothing</span>         <span class="z-keyword z-operator z-haskell">-></span> <span class="z-keyword z-control z-haskell">do</span>
     dataResult <span class="z-keyword z-operator z-haskell">&LT-</span> getFromSource userName
     storeCache dataResult
     return dataResult
 storeCache result
 return result
</span></code></pre><p>Here it is our basic program which implements what we described above, but obviously this code doesn't work because we need to define functions such as <code>getFromCache</code>, <code>getFromSource</code> and <code>storeCache</code>.<p>For defining that we are going to use <strong>Typeclasses</strong> as we mentioned, in order to represent our program capabilities.<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-declaration z-class z-haskell"><span class="z-keyword z-other z-haskell">class</span> <span class="z-support z-class z-prelude z-haskell">Monad</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> => <span class="z-entity z-other z-inherited-class z-haskell">Cache</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-keyword z-other z-haskell">where</span></span>
<span class="z-meta z-function z-type-declaration z-haskell">  <span class="z-entity z-name z-function z-haskell">getFromCache</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">String</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> (<span class="z-storage z-type z-haskell">Maybe</span> [<span class="z-storage z-type z-haskell">DataResult</span>])
</span><span class="z-meta z-function z-type-declaration z-haskell">  <span class="z-entity z-name z-function z-haskell">storeCache</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> [<span class="z-storage z-type z-haskell">DataResult</span>] <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-support z-constant z-unit z-haskell">()</span>

</span><span class="z-meta z-declaration z-class z-haskell"><span class="z-keyword z-other z-haskell">class</span> <span class="z-support z-class z-prelude z-haskell">Monad</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> => <span class="z-entity z-other z-inherited-class z-haskell">DataSource</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-keyword z-other z-haskell">where</span></span>
<span class="z-meta z-function z-type-declaration z-haskell">  <span class="z-entity z-name z-function z-haskell">getFromSource</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">String</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> [<span class="z-storage z-type z-haskell">DataResult</span>]

</span></span></code></pre><p>Why are we defining <code>Cache</code> and <code>DataSource</code> <strong>Typeclasses</strong> as <code>Monad</code> also? Basically because we want to combine and chain our <strong>DSL</strong> terms in a single program.<p>But we still need to change our program definition since we are constraining only on <code>Monad</code> and we want to use <code>Cache</code> and <code>DataSource</code> terms from the implicit context.<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">requestData</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> (<span class="z-storage z-type z-haskell">Cache</span> <span class="z-variable z-other z-generic-type z-haskell">m</span>, <span class="z-storage z-type z-haskell">DataSource</span> <span class="z-variable z-other z-generic-type z-haskell">m</span>) <span class="z-keyword z-other z-big-arrow z-haskell">=></span> <span class="z-storage z-type z-haskell">UserName</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> [<span class="z-storage z-type z-haskell">DataResult</span>]
</span>requestData userName <span class="z-keyword z-operator z-haskell">=</span> <span class="z-keyword z-control z-haskell">do</span>
 cache  <span class="z-keyword z-operator z-haskell">&LT-</span> getFromCache userName
 result <span class="z-keyword z-operator z-haskell">&LT-</span> <span class="z-keyword z-other z-haskell">case</span> cache <span class="z-keyword z-other z-haskell">of</span>
   <span class="z-constant z-other z-haskell">Just</span> dataResult <span class="z-keyword z-operator z-haskell">-></span> return dataResult
   <span class="z-constant z-other z-haskell">Nothing</span>         <span class="z-keyword z-operator z-haskell">-></span> getFromSource userName
 storeCache result
 return result
</span></code></pre><p>Notice that we don't need anymore <strong><code>Monad</code></strong> Constraint in our signature because both <code>Cache</code> and <code>DataSource</code> are <code>Monad</code>s also.<p>The only thing left is to write our <strong>Instances</strong> to provide some implementation. We are going to provide a fake implementation for <code>IO</code>.<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">Cache</span> <span class="z-storage z-type z-haskell">IO</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromCache _ <span class="z-keyword z-operator z-haskell">=</span> return <span class="z-constant z-other z-haskell">Nothing</span>
  storeCache _ <span class="z-keyword z-operator z-haskell">=</span> return <span class="z-constant z-language z-unit z-haskell">()</span>

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">DataSource</span> <span class="z-storage z-type z-haskell">IO</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromSource user <span class="z-keyword z-operator z-haskell">=</span> return <span class="z-keyword z-operator z-haskell">$</span> [<span class="z-constant z-other z-haskell">DataResult</span> <span class="z-keyword z-operator z-haskell">$</span> <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>source: <span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span> <span class="z-keyword z-operator z-haskell"><></span> user]
</span></code></pre><p>If we run our program from <strong>ghci</strong> we are going to see it is working:<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">Œªx.x> import Data

Œªx.x> requestData "john"
[DataResult "source: john"]
</span></code></pre><h2 id=provide-and-test-with-different-implementations-using-type-application>Provide and Test with different implementations using Type Application</h2><p>One of the things I have announced on the beginning of this post is i am going to show how easy it is to test our programs using this technique combined with <strong>TypeApplication</strong> LANGUAGE extension. This combination enable us not only to test, but also to provide and interchange different instances of our <strong>Typeclasses</strong> in a straightforward way.<h3 id=instances>Instances</h3><p>In order to provide different instances of <code>Cache</code> and <code>DataSource</code>, and play around with different cases, for example when data is in cache or not, i am going to wrappe <code>IO</code> type in different <code>newtype</code> representations.<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-preprocessor z-haskell">{-# <span class="z-keyword z-other z-preprocessor z-haskell">LANGUAGE</span> GeneralisedNewtypeDeriving #-}</span>

<span class="z-keyword z-other z-haskell">newtype</span> <span class="z-constant z-other z-haskell">NotInCache</span> a <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">NotInCache</span> { unNoCache <span class="z-keyword z-operator z-haskell">::</span> <span class="z-constant z-other z-haskell">IO</span> a }
  <span class="z-meta z-deriving z-haskell"><span class="z-keyword z-other z-haskell">deriving</span> (<span class="z-entity z-other z-inherited-class z-haskell">Monad</span>, <span class="z-entity z-other z-inherited-class z-haskell">Applicative</span>, <span class="z-entity z-other z-inherited-class z-haskell">Functor</span>)</span>

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">Cache</span> <span class="z-storage z-type z-haskell">NotInCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromCache _ <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">NotInCache</span> <span class="z-keyword z-operator z-haskell">$</span> return <span class="z-constant z-other z-haskell">Nothing</span>
  storeCache _ <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">NotInCache</span> <span class="z-keyword z-operator z-haskell">$</span> return <span class="z-constant z-language z-unit z-haskell">()</span>

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">DataSource</span> <span class="z-storage z-type z-haskell">NotInCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromSource user <span class="z-keyword z-operator z-haskell">=</span> return <span class="z-keyword z-operator z-haskell">$</span> [<span class="z-constant z-other z-haskell">DataResult</span> <span class="z-keyword z-operator z-haskell">$</span> <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>source: <span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span> <span class="z-keyword z-operator z-haskell"><></span> user]

</span></code></pre><p>For the first instance we need to do enable <strong>GeneralisedNewtypeDeriving</strong> extension to allow us deriving <code>Functor</code>, <code>Monad</code> and <code>Applicative</code> because our <strong>Typeclasses</strong> <code>Cache</code> and <code>DataSource</code> are also <code>Monad</code> and we need to provide implementations of those <strong>Typeclasses</strong> for our custom type <code>NotInCache</code><p>Now if we are trying to run this in <strong>ghci</strong> we are getting the following error:<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">Œªx.x> requestData "john"

&LTinteractive>:5:1: error:
    ‚Ä¢ Ambiguous type variable ‚Äòm0‚Äô arising from a use of ‚Äòprint‚Äô
      prevents the constraint ‚Äò(Show
                                  (m0 [DataResult]))‚Äô from being solved.
      Probable fix: use a type annotation to specify what ‚Äòm0‚Äô should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‚ÄòData.Either‚Äô
        instance Show a => Show (Maybe a) -- Defined in ‚ÄòGHC.Show‚Äô
        instance (Show a, Show b) => Show (a, b) -- Defined in ‚ÄòGHC.Show‚Äô
        ...plus 14 others
        ...plus 89 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    ‚Ä¢ In a stmt of an interactive GHCi command: print it
</span></code></pre><p>Basically the compiler is saying us that it cannot find an unambiguous instance to use for our program. But also as the compiler is pointed out we can use <strong>TypeApplication</strong> extension to tell the compiler what instance should use and provide an explicit evidence of that.<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">Œªx.x> :set -XTypeApplications

Œªx.x> :t requestData "john"
requestData "john"
  :: (Data.Cache m, DataSource m, Data.Logging m) => m [DataResult]
Œªx.x> :t requestData @NotInCache "john"
requestData @NotInCache "john" :: NotInCache [DataResult]

</span></code></pre><p>Here we've enabled extension and after that we are running our program with <code>NotInCache</code> type. Notice that now we need to call <code>unNoCache</code> to unwrap our underlying <code>IO</code> and effectively running in our <strong>ghci</strong> <code>IO</code> loop.<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">x.x> unNoCache $ requestData "john"
[DataResult "source: john"]
</span></code></pre><p>We can also do it from our <strong>.hs</strong> file.<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">main</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">IO</span> <span class="z-support z-constant z-unit z-haskell">()</span>
</span>main <span class="z-keyword z-operator z-haskell">=</span> (unNoCache <span class="z-keyword z-operator z-haskell">$</span> requestData <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>john<span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span>) <span class="z-keyword z-operator z-haskell">>>=</span> (putStrLn <span class="z-keyword z-operator z-haskell">.</span> show)
</span></code></pre><p>Now we are ready for different instances!!!<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-keyword z-other z-haskell">newtype</span> <span class="z-constant z-other z-haskell">InCache</span> a <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">InCache</span> { unInCache <span class="z-keyword z-operator z-haskell">::</span> <span class="z-constant z-other z-haskell">IO</span> a }
  <span class="z-meta z-deriving z-haskell"><span class="z-keyword z-other z-haskell">deriving</span> (<span class="z-entity z-other z-inherited-class z-haskell">Monad</span>, <span class="z-entity z-other z-inherited-class z-haskell">Applicative</span>, <span class="z-entity z-other z-inherited-class z-haskell">Functor</span>)</span>

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">Cache</span> <span class="z-storage z-type z-haskell">InCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromCache user <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">InCache</span> <span class="z-keyword z-operator z-haskell">$</span> return <span class="z-keyword z-operator z-haskell">$</span> <span class="z-constant z-other z-haskell">Just</span> [<span class="z-constant z-other z-haskell">DataResult</span> <span class="z-keyword z-operator z-haskell">$</span> <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>cache: <span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span> <span class="z-keyword z-operator z-haskell"><></span> user]
  storeCache _ <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">InCache</span> <span class="z-keyword z-operator z-haskell">$</span> return <span class="z-constant z-language z-unit z-haskell">()</span>

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">DataSource</span> <span class="z-storage z-type z-haskell">InCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  getFromSource _ <span class="z-keyword z-operator z-haskell">=</span> undefined

<span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">main</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">IO</span> <span class="z-support z-constant z-unit z-haskell">()</span>
</span>main <span class="z-keyword z-operator z-haskell">=</span> <span class="z-keyword z-control z-haskell">do</span>
  (unNoCache <span class="z-keyword z-operator z-haskell">$</span> requestData <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>john<span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span>) <span class="z-keyword z-operator z-haskell">>>=</span> (putStrLn <span class="z-keyword z-operator z-haskell">.</span> show)
  (unInCache <span class="z-keyword z-operator z-haskell">$</span> requestData <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>john<span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span>) <span class="z-keyword z-operator z-haskell">>>=</span> (putStrLn <span class="z-keyword z-operator z-haskell">.</span> show)
</span></code></pre><p>The outputs now look like this:<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">Œªx.x> Data.main
[DataResult "source: john"]
[DataResult "cache: john"]
</span></code></pre><h2 id=extensibility>Extensibility</h2><p>One of the important aspects of <strong>Tagless Final Encoding</strong> is its extensibility property. It is extensible in 2 dimensions:<ul><li><p><strong>Vertical Extensibility</strong>: It is what we have just done adding different implementations for the same <strong>Typeclasses</strong> without altering our program.</p><li><p><strong>Horizontal Extensibility</strong>: It is adding new capabilities to the program in order to extend some functionality inside it.</p></ul><h3 id=horizontal-extensibility>Horizontal Extensibility</h3><p>Our program capabilities beyond <code>Monad</code>, <code>Functor</code> and <code>Applicative</code> <strong>Typeclasses</strong> are <code>Cache</code> and <code>DataSource</code>. If we are saying that it is <em>Horizontal Extensible</em> we can add more capabilities apart from those mentioned. For example what about <code>Logging</code>?.<p>Let do it with our example:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell">
<span class="z-meta z-declaration z-class z-haskell"><span class="z-keyword z-other z-haskell">class</span> <span class="z-support z-class z-prelude z-haskell">Monad</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> => <span class="z-entity z-other z-inherited-class z-haskell">Logging</span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-keyword z-other z-haskell">where</span></span>
<span class="z-meta z-function z-type-declaration z-haskell">  <span class="z-entity z-name z-function z-haskell">logMsg</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">String</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> <span class="z-support z-constant z-unit z-haskell">()</span>

</span><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">requestData</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> (<span class="z-storage z-type z-haskell">Cache</span> <span class="z-variable z-other z-generic-type z-haskell">m</span>, <span class="z-storage z-type z-haskell">DataSource</span> <span class="z-variable z-other z-generic-type z-haskell">m</span>, <span class="z-storage z-type z-haskell">Logging</span> <span class="z-variable z-other z-generic-type z-haskell">m</span>) <span class="z-keyword z-other z-big-arrow z-haskell">=></span> <span class="z-storage z-type z-haskell">UserName</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-variable z-other z-generic-type z-haskell">m</span> [<span class="z-storage z-type z-haskell">DataResult</span>]
</span>requestData userName <span class="z-keyword z-operator z-haskell">=</span> <span class="z-keyword z-control z-haskell">do</span>
 cache  <span class="z-keyword z-operator z-haskell">&LT-</span> getFromCache userName
 result <span class="z-keyword z-operator z-haskell">&LT-</span> <span class="z-keyword z-other z-haskell">case</span> cache <span class="z-keyword z-other z-haskell">of</span>
   <span class="z-constant z-other z-haskell">Just</span> dataResult <span class="z-keyword z-operator z-haskell">-></span> return dataResult
   <span class="z-constant z-other z-haskell">Nothing</span>         <span class="z-keyword z-operator z-haskell">-></span> getFromSource userName
 storeCache result
 logMsg <span class="z-keyword z-operator z-haskell">$</span> <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>Result data for user: <span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span> <span class="z-keyword z-operator z-haskell"><></span> userName <span class="z-keyword z-operator z-haskell"><></span> <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span> - data: <span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span> <span class="z-keyword z-operator z-haskell"><></span> show result
 return result

</span></code></pre><p>And now providing instances for <code>Logging</code><pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">Logging</span> <span class="z-storage z-type z-haskell">NotInCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  logMsg <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">NotInCache</span> <span class="z-keyword z-operator z-haskell">.</span> putStrLn

<span class="z-meta z-declaration z-instance z-haskell"><span class="z-keyword z-other z-haskell">instance</span> <span class="z-storage z-type z-haskell">Logging</span> <span class="z-storage z-type z-haskell">InCache</span> <span class="z-keyword z-other z-haskell">where</span></span>
  logMsg <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">InCache</span> <span class="z-keyword z-operator z-haskell">.</span> putStrLn

</span></code></pre><p>If we run the program we obtain the following:<pre class="language-shell z-code" data-lang=shell><code class=language-shell data-lang=shell><span class="z-text z-plain">Œªx.x> Data.main
Result data for user: john - data: [DataResult "source: john"]
[DataResult "source: john"]
Result data for user: john - data: [DataResult "cache: john"]
[DataResult "cache: john"]
</span></code></pre><h2 id=conclusion>Conclusion</h2><p>As we can see, <strong>Tagless Final Encoding</strong> is a pretty good technique to build testable and extensible programs.<p>We have also demonstrated how easy is to interchange and provide different instances using <strong>TypeApplication</strong> extension.</section></article></main></div><footer><section><nav><a class="nav-links social" rel="noopener noreferrer" href=https://github.com/jproyo target=_blank> <img alt=github src=/social_icons/github.svg title=github> </a><a class="nav-links social" rel="noopener noreferrer" href=https://www.linkedin.com/in/juanpabloroyo/ target=_blank> <img alt=linkedin src=/social_icons/linkedin.svg title=linkedin> </a><a class="nav-links social" rel="noopener noreferrer" href=https://twitter.com/juanpabloroyo target=_blank> <img alt=twitter src=/social_icons/twitter.svg title=twitter> </a><a class="nav-links social" rel="noopener noreferrer" href=mailto:juanpablo.royo@gmail.com target=_blank> <img alt=email src=/social_icons/email.svg title=email> </a><a class="nav-links social" rel="noopener noreferrer" href=/atom.xml target=_blank> <img alt=rss src=/social_icons/rss.svg title=rss> </a><a class="nav-links social" rel="noopener noreferrer" href=https://www.reddit.com/user/jproyo target=_blank> <img alt=reddit src=/social_icons/reddit.svg title=reddit> </a></nav><nav><span classname=desktop-only>This blog is powered by <a rel="noopener noreferrer" href=https://getzola.org/ target=_blank>Zola</a> with theme by <a rel="noopener noreferrer" href=https://syedzayyan.com/ target=_blank>SZM</a></span></nav></section><script src=https://jproyo.github.io/js/main.js></script></footer>